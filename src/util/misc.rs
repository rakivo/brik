//! Helper functions and macros

use crate::rv32::Reg;
use crate::rv64::I64::{self, *};

use core::fmt;
use core::ops::{Shl, Neg};

use num_traits::{Num, Bounded, FromBytes, PrimInt};

pub trait FitCheckable<T>: Num + Bounded + PartialOrd + Shl<usize, Output = T> + Neg<Output = T> {}

impl<T> FitCheckable<T> for T
where
    T: Num + Bounded + PartialOrd + Shl<usize, Output = T> + Neg<Output = T>
{}

#[inline(always)]
pub fn int_fits_into_12_bits<T: FitCheckable<T>>(v: T) -> bool {
    int_fits_into_bits(v, 12)
}

#[inline(always)]
pub fn int_fits_into_32_bits<T: FitCheckable<T>>(v: T) -> bool {
    int_fits_into_bits(v, 32)
}

#[inline(always)]
pub fn int_fits_into_64_bits<T: FitCheckable<T>>(v: T) -> bool {
    int_fits_into_bits(v, 64)
}

// Check if T fits into N bits
#[inline(always)]
pub fn int_fits_into_bits<T: FitCheckable<T>>(v: T, bits: usize) -> bool {
    // Calculate the bounds for a signed integer with N bits.
    // Upper bound: 2^(N-1) - 1
    // Lower bound: -2^(N-1)
    let upper = (T::one() << (bits - 1)) - T::one();
    let lower = -(T::one() << (bits - 1));

    v >= lower && v <= upper
}

/// Convert `v` from 1-based to 0-based, clamping the result with `cap`
///
/// # Examples
///
/// ```
/// # const fn b0(v: usize, cap: usize) -> usize {
/// #     let v = v.saturating_sub(1);
/// #     if v < cap { v } else { cap }
/// # }
///
/// assert_eq!(b0(1, 10), 0);   // 1-based 1 -> 0-based 0
/// assert_eq!(b0(5, 10), 4);   // 1-based 5 -> 0-based 4
/// assert_eq!(b0(0, 10), 0);   // saturating_sub prevents underflow; 0 saturates to 0
/// assert_eq!(b0(15, 10), 10); // clamped to cap = 10
/// assert_eq!(b0(11, 10), 10); // clamped to cap = 10
/// ```
#[inline(always)]
pub const fn b0(v: usize, cap: usize) -> usize {
    let v = v.saturating_sub(1);
    if v < cap { v } else { cap }
}

/// Decode a sequence of RV64 little-endian instructions (LUI/ADDI/SLLI/ORI) into a single immediate.
/// Assumes the instructions are generated by `encode_li_rv64_little`.
pub fn decode_li64_little(bytes: &[u8], rd: Reg) -> i64 {
    use crate::rv32::Reg::*;
    use crate::rv32::I32::{self, *};
    use crate::util::misc::le_bytes_into_int as lint;

    let mut offset = 0;
    let mut imm = 0u64;

    while offset < bytes.len() {
        let inst_word = lint(&bytes[offset..offset + 4]);

        // Try to decode as 32-bit instruction first
        match I32::try_from_u32(inst_word) {
            Ok(inst32) => match inst32 {
                LUI { d, im } if d == rd => {
                    imm = ((im as u32 & 0x000FFFFF) as u64) << 12; // Mask to 20 bits, treat as unsigned
                }
                ADDI { d, s, im } if d == rd && s == rd => {
                    imm = imm.wrapping_add(im as i64 as u64);
                }
                ADDI { d, s, im } if d == rd && s == ZERO => {
                    imm = im as i64 as u64;
                }
                SLLI { d, s, shamt } if d == rd && s == rd => {
                    imm <<= shamt ;
                }
                ORI { d, s, im } if d == rd && s == rd => {
                    imm |= (im as u32 & 0x00000FFF) as u64; // Ensure 12-bit unsigned
                }
                _ => panic!("Unexpected instruction: {inst32:?}"),
            }

            Err(e) => {
                println!("I32::try_from_u32 returned error: {e:?}, trying I64::try_from_u32..");
                match I64::try_from_u32(inst_word) {
                    Ok(inst64) => match inst64 {
                        SLLIW { d, s, shamt } if d == rd && s == rd => {
                            imm <<= shamt;
                        }
                        SRLIW { d, s, shamt } if d == rd && s == rd => {
                            imm >>= shamt;
                        }
                        _ => panic!("Unexpected instruction: {inst64:?}"),
                    }

                    Err(e) => panic!{
                        "Cannot decode instruction word: 0x{:08x} at offest: {offset}: {e:?}", inst_word
                    }
                }
            }
        }

        offset += 4;
    }

    imm as _
}

/// Decode a sequence of RV32 little-endian instructions (LUI/ADDI/SLLI/ORI) into a single immediate.
/// Assumes the instructions are generated by `encode_li_rv32_little`.
pub fn decode_li32_little(bytes: &[u8], rd: Reg) -> i32 {
    use crate::rv32::Reg::*;
    use crate::rv32::I32::{self, *};
    use crate::util::misc::le_bytes_into_int as lint;

    let mut offset = 0;
    let mut imm = 0u32;

    while offset < bytes.len() {
        let inst_word = lint(&bytes[offset..offset + 4]);

        // Try to decode as 32-bit instruction first
        match I32::try_from_u32(inst_word) {
            Ok(inst32) => match inst32 {
                LUI { d, im } if d == rd => {
                    imm = ((im as u32 & 0x000FFFFF) as u32) << 12
                }
                ADDI { d, s, im } if d == rd && s == rd => {
                    imm = imm.wrapping_add(im as i32 as u32)
                }
                ADDI { d, s, im } if d == rd && s == ZERO => {
                    imm = im as i32 as u32
                }
                _ => panic!("Unexpected instruction: {inst32:?}"),
            }

            Err(e) => panic!("couldn't decode inst_word: 0x{inst_word:X}: {e:?}")
        }

        offset += 4;
    }

    imm as _
}

#[track_caller]
#[inline(always)]
#[doc(alias = "lint")]
pub fn le_bytes_into_int<T>(bytes: &[u8]) -> T
where
    T: PrimInt + FromBytes,
    <T as FromBytes>::Bytes: Sized + for<'a> TryFrom<&'a [u8]>,
    for<'a> <<T as FromBytes>::Bytes as TryFrom<&'a [u8]>>::Error: fmt::Debug,
{
    let array: <T as FromBytes>::Bytes = bytes.try_into().expect("wrong length");
    T::from_le_bytes(&array)
}

#[track_caller]
#[inline(always)]
#[doc(alias = "bint")]
pub fn be_bytes_into_int<T>(bytes: &[u8]) -> T
where
    T: PrimInt + FromBytes,
    <T as FromBytes>::Bytes: Sized + for<'a> TryFrom<&'a [u8]>,
    for<'a> <<T as FromBytes>::Bytes as TryFrom<&'a [u8]>>::Error: fmt::Debug,
{
    let array: <T as FromBytes>::Bytes = bytes.try_into().expect("wrong length");
    T::from_be_bytes(&array)
}

#[doc(hidden)]
macro_rules! debug_from_display {
    ($type: ty, newline) => {
        const _: fn() = || {
            fn assert_impl_display<T: std::fmt::Display>() {}
            assert_impl_display::<$type>();
        };

        impl std::fmt::Debug for $type {
            #[inline(always)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                writeln!(f)?;
                std::fmt::Display::fmt(self, f)
            }
        }
    };

    ($type: ty) => {
        const _: fn() = || {
            fn assert_impl_display<T: std::fmt::Display>() {}
            assert_impl_display::<$type>();
        };

        impl std::fmt::Debug for $type {
            #[inline(always)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                std::fmt::Display::fmt(self, f)
            }
        }
    };
}

macro_rules! assembler_method {
    ($name: ident) => {
        concat!{
            "crate::asm::Assembler::",
            stringify!($name),
        }
    };
}

// TODO(#20): Make `with_at_end!` support for generics and `where` clauses
macro_rules! with_at_end {
    (
        $at_end_name:ident,
        $(#[$meta:meta])*
        $vis:vis fn $name:ident
        $(<$($generics:tt),*>)?
        (
            &mut $self:ident $(, $param_name:ident: $param_type:ty $(,)?)*
        ) $(-> $ret:ty)? $body:block
    ) => {
        $(#[$meta])*
        $vis fn $name
        $(<$($generics),*>)?
        (&mut $self $(, $param_name: $param_type)*)
        $(-> $ret)?
        $body

        $(#[$meta])*
        #[inline(always)]
        #[allow(unused_attributes)]
        #[doc = concat!{
            "Calls [`",
            assembler_method!($name),
            "`] and sets current section to the created one"
        }]
        $vis fn $at_end_name
        $(<$($generics),*>)?
        (&mut $self $(, $param_name: $param_type)*)
        $(-> $ret)?
        {
            let sid = $self.$name($($param_name),*);
            $self.position_at_end(sid);
            sid
        }
    };
}

// TODO(#19): Make `with_at!` support for generics and `where` clauses
macro_rules! with_no_at {
    // section version
    (
        $no_at_name: ident,
        $(#[$meta:meta])*
        $vis:vis fn $name_at:ident
        $(<$($generics:tt),*>)?
        (
            &mut $self:ident,
            $section:ident: $section_type:ty $(, $arg:ident: $ty:ty $(,)?)*
        ) $(-> $ret:ty)? $body:block
    ) => {
        $(#[$meta])*
        $vis fn $name_at
        $(<$($generics),*>)?
        (
            &mut $self, $section: $section_type $(, $arg: $ty)*
        )
        $(-> $ret)?
        $body

        $(#[$meta])*
        #[track_caller]
        #[inline(always)]
        #[allow(unused_attributes)]
        #[doc = concat!{
            "Calls [`",
            assembler_method!($name_at),
            "`] with current section"
        }]
        $vis fn $no_at_name
        $(<$($generics),*>)?
        (&mut $self $(, $arg: $ty)*)
        $(-> $ret)?
        {
            let $section = $self.expect_curr_section();
            $self.$name_at($section $(, $arg)*)
        }
    };

    // symbol version
    (
        symbol
        $no_at_name: ident,
        $(#[$meta:meta])*
        pub fn $name_at:ident
        $(<$($generics:tt),*>)?
        (
            &mut $self:ident,
            $section:ident: $section_type:ty $(, $arg:ident: $ty:ty $(,)?)*
        ) $(-> $ret:ty)? $body:block
    ) => {

        $(#[$meta])*
        pub fn $name_at
        $(<$($generics),*>)?
        (
            &mut $self, $section: $section_type $(, $arg: $ty)*
        ) $(-> $ret)? $body

        $(#[$meta])*
        #[track_caller]
        #[inline(always)]
        #[allow(unused_attributes)]
        #[doc = concat!{
            "Calls [`",
            assembler_method!($name_at),
            "`] with current section"
        }]
        pub fn $no_at_name
        $(<$($generics),*>)?
        (&mut $self $(, $arg: $ty)*)
        $(-> $ret)?
        {
            let $section = $self.expect_curr_section();
            let $section = $crate::object::write::SymbolSection::Section($section);
            $self.$name_at($section $(, $arg)*)
        }
    };
}
