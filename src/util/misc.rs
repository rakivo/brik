//! Helper functions and macros

use crate::rv32::Reg;

use core::fmt;

use num_traits::{PrimInt, FromBytes};

/// Convert `v` from 1-based to 0-based, clamping the result with `cap`
///
/// # Examples
///
/// ```
/// # const fn b0(v: usize, cap: usize) -> usize {
/// #     let v = v.saturating_sub(1);
/// #     if v < cap { v } else { cap }
/// # }
///
/// assert_eq!(b0(1, 10), 0);   // 1-based 1 -> 0-based 0
/// assert_eq!(b0(5, 10), 4);   // 1-based 5 -> 0-based 4
/// assert_eq!(b0(0, 10), 0);   // saturating_sub prevents underflow; 0 saturates to 0
/// assert_eq!(b0(15, 10), 10); // clamped to cap = 10
/// assert_eq!(b0(11, 10), 10); // clamped to cap = 10
/// ```
#[inline(always)]
pub const fn b0(v: usize, cap: usize) -> usize {
    let v = v.saturating_sub(1);
    if v < cap { v } else { cap }
}

/// Decode a sequence of RV64 little-endian instructions (LUI/ADDI) into a single immediate.
/// Assumes the instructions are generated by `encode_li_rv64_little`.
pub fn decode_li64_little(bytes: &[u8], rd: Reg) -> i64 {
    use crate::rv32::Reg::*;
    use crate::rv32::I32::{self, *};
    use crate::util::misc::le_bytes_into_int as lint;

    let mut offset = 0;
    let mut imm = 0i64;

    while offset < bytes.len() {
        let inst_word = lint(&bytes[offset..offset + 4]);

        // Try to decode as 32-bit instruction first
        if let Ok(inst32) = I32::try_from_u32(inst_word) {
            match inst32 {
                LUI { d, im } if d == rd => {
                    imm = (im as i64) << 12;
                }
                ADDI { d, s, im } if d == rd && s == rd => {
                    imm += im as i64;
                }
                ADDI { d, s, im } if d == rd && s == ZERO => {
                    imm = im as i64;
                }
                SLLI { d, s, im } if d == rd && s == rd => {
                    imm <<= im;
                }
                _ => {
                    panic!("Unexpected 32-bit instruction when decoding li: {inst32:?}");
                }
            }
        } else {
            panic!("Cannot decode instruction word: 0x{:08x}", inst_word);
        }

        offset += 4;
    }
    imm
}

/// Decode a sequence of little-endian instructions (LUI/ADDI) generated by `li`
/// into a single immediate. Works for RV32 and RV64.
///
/// `rd` is the target register used in `li`.
pub fn decode_li32_little(bytes: &[u8], rd: Reg) -> i64 {
    use crate::rv32::Reg::*;
    use crate::rv32::I32::{self, *};
    use crate::util::misc::le_bytes_into_int as lint;

    let mut offset = 0;
    let mut imm = 0i64;

    while offset < bytes.len() {
        let inst = I32::try_from_u32(lint(&bytes[offset..offset + 4])).unwrap();
        match inst {
            LUI { d, im } if d == rd => {
                imm = (im as i64) << 12;
            }
            ADDI { d, s, im } if d == rd && s == rd => {
                // ADDI after LUI
                imm += im as i64;
            }
            ADDI { d, s, im } if d == rd && s == ZERO => {
                // single-instruction li
                imm = im as i64;
            }
            _ => panic!("Unexpected instruction when decoding li: {inst:?}"),
        }
        offset += 4;
    }

    imm
}

#[track_caller]
#[inline(always)]
#[doc(alias = "lint")]
pub fn le_bytes_into_int<T>(bytes: &[u8]) -> T
where
    T: PrimInt + FromBytes,
    <T as FromBytes>::Bytes: Sized + for<'a> TryFrom<&'a [u8]>,
    for<'a> <<T as FromBytes>::Bytes as TryFrom<&'a [u8]>>::Error: fmt::Debug,
{
    let array: <T as FromBytes>::Bytes = bytes.try_into().expect("wrong length");
    T::from_le_bytes(&array)
}

#[track_caller]
#[inline(always)]
#[doc(alias = "bint")]
pub fn be_bytes_into_int<T>(bytes: &[u8]) -> T
where
    T: PrimInt + FromBytes,
    <T as FromBytes>::Bytes: Sized + for<'a> TryFrom<&'a [u8]>,
    for<'a> <<T as FromBytes>::Bytes as TryFrom<&'a [u8]>>::Error: fmt::Debug,
{
    let array: <T as FromBytes>::Bytes = bytes.try_into().expect("wrong length");
    T::from_be_bytes(&array)
}

// Check if T fits into 12-bits integer (i12)
#[inline(always)]
pub fn fits_into_12_bits<T: TryInto<i16>>(v: T) -> bool {
    const BOUND: i16 = 1 << (12 - 1);

    matches!{
        v.try_into(),
        Ok(v) if v > -BOUND && v < BOUND
    }
}

#[doc(hidden)]
macro_rules! debug_from_display {
    ($type: ty, newline) => {
        const _: fn() = || {
            fn assert_impl_display<T: std::fmt::Display>() {}
            assert_impl_display::<$type>();
        };

        impl std::fmt::Debug for $type {
            #[inline(always)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                writeln!(f)?;
                std::fmt::Display::fmt(self, f)
            }
        }
    };

    ($type: ty) => {
        const _: fn() = || {
            fn assert_impl_display<T: std::fmt::Display>() {}
            assert_impl_display::<$type>();
        };

        impl std::fmt::Debug for $type {
            #[inline(always)]
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                std::fmt::Display::fmt(self, f)
            }
        }
    };
}

macro_rules! assembler_method {
    ($name: ident) => {
        concat!{
            "crate::asm::Assembler::",
            stringify!($name),
        }
    };
}

// TODO(#20): Make `with_at_end!` support for generics and `where` clauses
macro_rules! with_at_end {
    (
        $at_end_name:ident,
        $(#[$meta:meta])*
        $vis:vis fn $name:ident
        $(<$($generics:tt),*>)?
        (
            &mut $self:ident $(, $param_name:ident: $param_type:ty $(,)?)*
        ) $(-> $ret:ty)? $body:block
    ) => {
        $(#[$meta])*
        $vis fn $name
        $(<$($generics),*>)?
        (&mut $self $(, $param_name: $param_type)*)
        $(-> $ret)?
        $body

        $(#[$meta])*
        #[inline(always)]
        #[allow(unused_attributes)]
        #[doc = concat!{
            "Calls [`",
            assembler_method!($name),
            "`] and sets current section to the created one"
        }]
        $vis fn $at_end_name
        $(<$($generics),*>)?
        (&mut $self $(, $param_name: $param_type)*)
        $(-> $ret)?
        {
            let sid = $self.$name($($param_name),*);
            $self.position_at_end(sid);
            sid
        }
    };
}

// TODO(#19): Make `with_at!` support for generics and `where` clauses
macro_rules! with_no_at {
    // section version
    (
        $no_at_name: ident,
        $(#[$meta:meta])*
        $vis:vis fn $name_at:ident
        $(<$($generics:tt),*>)?
        (
            &mut $self:ident,
            $section:ident: $section_type:ty $(, $arg:ident: $ty:ty $(,)?)*
        ) $(-> $ret:ty)? $body:block
    ) => {
        $(#[$meta])*
        $vis fn $name_at
        $(<$($generics),*>)?
        (
            &mut $self, $section: $section_type $(, $arg: $ty)*
        )
        $(-> $ret)?
        $body

        $(#[$meta])*
        #[track_caller]
        #[inline(always)]
        #[allow(unused_attributes)]
        #[doc = concat!{
            "Calls [`",
            assembler_method!($name_at),
            "`] with current section"
        }]
        $vis fn $no_at_name
        $(<$($generics),*>)?
        (&mut $self $(, $arg: $ty)*)
        $(-> $ret)?
        {
            let $section = $self.expect_curr_section();
            $self.$name_at($section $(, $arg)*)
        }
    };

    // symbol version
    (
        symbol
        $no_at_name: ident,
        $(#[$meta:meta])*
        pub fn $name_at:ident
        $(<$($generics:tt),*>)?
        (
            &mut $self:ident,
            $section:ident: $section_type:ty $(, $arg:ident: $ty:ty $(,)?)*
        ) $(-> $ret:ty)? $body:block
    ) => {

        $(#[$meta])*
        pub fn $name_at
        $(<$($generics),*>)?
        (
            &mut $self, $section: $section_type $(, $arg: $ty)*
        ) $(-> $ret)? $body

        $(#[$meta])*
        #[track_caller]
        #[inline(always)]
        #[allow(unused_attributes)]
        #[doc = concat!{
            "Calls [`",
            assembler_method!($name_at),
            "`] with current section"
        }]
        pub fn $no_at_name
        $(<$($generics),*>)?
        (&mut $self $(, $arg: $ty)*)
        $(-> $ret)?
        {
            let $section = $self.expect_curr_section();
            let $section = $crate::object::write::SymbolSection::Section($section);
            $self.$name_at($section $(, $arg)*)
        }
    };
}
